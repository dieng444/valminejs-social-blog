var DB = require('../mongodb-manager/DB')
  , ObjectID = require('mongodb').ObjectID
  , util = require('../utils/util')
  , ValmineError = require('../utils/error');

/**
* Represents the  main model class
* @class MainModel
* @author Macky Dieng
* @license MIT - http://opensource.org/licenses/MIT
* @copyright 2016 the author
*
* @param {string} collection - the collection of current manager
* @param {Object} Entity - The entity of current manager
*
* @property {mongodb-manager/DB} db - The database instance to use
* @property {string} idKey - The field to use for retrieve the document in database collection
* @property {Object} filter - The filter object to use for a custom query
*/
function MainModel(collection, Entity) {

  /***
  * The database instance variable
  */
  var db = new DB().getInstance();

  /***
  * he field to use for retrieve the document in database collection
  */
  var idKey = '_id';


  /***
  * Object to use for a custom query
  */
  var filter = {};

  /****Errors checking****/
  if(collection==null)
    throw new ValmineError.getInstance('You must specify the collection to use in your current manager');
  if(Entity==null)
    throw new ValmineError.getInstance('You must specify entity to use in your current manager');

  /**
  * Private helper method, allows to parse document coming from database
  * @method
  * @param {Object} doc - document to parse
  * @returns {Object}
  **/
  var getParsedDoc = function(doc) {
    doc.id = doc._id; /***Creating correct attr id since doc._id generated by mongodb***/
    delete doc._id; /***Now we can delete the _id on the document***/
    var entity = new Entity(doc);
    return entity;
  }

  /**
  * Retrives a single object in collection from database
  * @method
  * @throws {ValmineError}
  * @param {string} id - the unique id of object to retrive
  * @param {function} callback - function to call after the treatment
  * @returns {void}
  */
  this.findOne = function(id,callback) {
    if (!id || typeof id == 'function')
        throw new ValmineError.getInstance(new TypeError(util.getParamErr('findOne','id')));
    if(util.isCallbackMissed(callback))
        throw new ValmineError.getInstance(new TypeError(util.getParamErr('findOne','callback')));
    filter[idKey] = new ObjectID(id);/****Getting the document id from MongoDB ObjectID constructor****/
    db.collection(collection).findOne(filter,{}, function(err, doc) {
      if(err) console.log(err);
      if (doc!=null) {
        var entity = getParsedDoc(doc);
        callback(err,entity);
      } else {
        callback(err,doc);
        filter = [];
      }
    });
    filter = [];
  }

  /**
  * Retrives a single object in collection by filter
  * @method
  * @throws {ValmineError}
  * @param {Object}  filter - filter to use for the request
  * @param {function} callback - function to call after the treatment
  * @returns {callback}
  */
  this.findOneBy = function(filter,callback) {
    if (!filter || typeof filter=='function')
        throw new ValmineError.getInstance(new TypeError(util.getParamErr('findOneBy','filter')));
    if(util.isCallbackMissed(callback))
        throw new ValmineError.getInstance(new TypeError(util.getParamErr('findOneBy','callback')));
    db.collection(collection).findOne(filter,{}, function(err, doc) {
      if(err) console.log(err);
      if(doc !== null) {
        var entity = getParsedDoc(doc);
        callback(err,entity);
      } else {
        callback(err,doc);
      }
    });
  }

  /**
  * Retrives all entries of given collection
  * @method
  * @throws {ValmineError}
  * @param {function} callback - function to call after the treatment
  * @returns {callback}
  **/
  this.findAll = function(callback) {
    if(util.isCallbackMissed(callback))
      throw new ValmineError.getInstance(new TypeError(util.getParamErr('findAll','callback')));
    db.collection(collection).find(filter).toArray(function(err, docs) {
      if(err) console.log(err);
      if(docs.length > 0) {
        var objects = new Array();
        for(i in docs) {
          var entity = getParsedDoc(docs[i]);
          objects.push(entity);
        }
        callback(err,objects);
      } else {
        callback(err,docs);
      }
    });
  }

  /**
  * Retrieves many objects in collection by filter
  * @method
  * @throws {ValmineError}
  * @param {Object}  filter - the filter to use for the request
  * @param {function} callback - function to call after the treatment
  * @returns {callback}
  */
  this.findAllBy = function(filter, callback) {
    if(!filter || typeof filter == 'function')
      throw new ValmineError.getInstance(new TypeError(util.getParamErr('findAllBy','filter')));
    if(util.isCallbackMissed(callback))
      throw new ValmineError.getInstance(new TypeError(util.getParamErr('findAllBy','callback')));
    db.collection(collection).find(filter).toArray(function(err, docs) {
      if(err) console.log(err);
      if(docs.length > 0) {
        var objects = new Array();
        for(i in docs) {
          var entity = getParsedDoc(docs[i]);
          objects.push(entity);
        }
        callback(err,objects);
      } else {
        callback(err,docs);
      }
    });
  }

  /**
  * Private method,
  * parses all given objects and prepare them for insert or update in database
  * @method
  * @throws {ValmineError}
  * @param {function} callback - function to call when everything went well
  * @returns {callback}
  */
  var oParser = function(entity, callback) {
    if(util.isCallbackMissed(callback))
      throw new ValmineError.getInstance(new TypeError(util.getParamErr('oParser','callback')));
    var data = {}
      , attribut = null
      , getter = null
      , objectId = null;
    for(method in entity) {
      if(/set/.test(method)) {
        attribut = method.substring(3,method.length); /***Will return "FirstName" from "setFirstNam"**/
        attribut = attribut.charAt(0).toLowerCase() + attribut.slice(1); /***Will return "firstName" from "FirstName"*/
        getter = 'get'+attribut.charAt(0).toUpperCase() + attribut.slice(1); //Will return "getFirstName" from firstName
        if (getter!='getId') { /***Object id is null here so o.getId() will return null*/
          if(typeof entity[getter]=='undefined')
            throw new ValmineError.getInstance('undefined method '+getter+', please checks the method definition in your class')
          else data[attribut] = entity[getter]();
        }
        else
          objectId = entity[getter](); //Storing separately the object id for update mode
      }
    }
    if(util.isEmpty(data))
      throw new ValmineError.getInstance('Setters of all objects must imperatively be preceded by the string "set"');
      data = {id: objectId, d: data};
    callback(data);
  }

  /**
  * Save a single entity in database collection
  * @method
  * @throws {ValmineError}
  * @returns {callback}
  */
  this.save = function(entity,callback) {
    if(!entity)
      throw new ValmineError.getInstance(new TypeError(util.getParamErr('save','entity')));
    if(util.isEmpty(entity))
      throw new ValmineError.getInstance('You are trying to save empty entity');
    if(util.isCallbackMissed(callback))
      throw new ValmineError.getInstance(new TypeError(util.getParamErr('save','callback')));
    oParser(entity, function(obj) {
        if(obj.id!==null) { //Update mode, object id is not null (object already exists)
          filter[idKey] = new ObjectID(obj.id);
          db.collection(collection).updateOne(filter,{$set:obj.d},function(err, res) {
            if(err) console.error(err);
            callback(err,res);
          });
        } else { //insert mode, object id is null (new object)
          db.collection(collection).insertOne(obj.d, function(err, res) {
            if(err) console.error(err);
            callback(err, {lastInsertedId:res.insertedId});
          });
        }
    });
  }

  /**
  * Removes a single specific object
  * @method
  * @throws {ValmineError}
  * @param {Object} obj - the object to remove
  * @param {funtion} callback - the function to call when everything went well
  * @returns {callback}
  */
  this.remove = function(obj, callback) {
    if (!obj)
      throw new ValmineError.getInstance(new TypeError(util.getParamErr('remove','object')));
    if (obj['getId'] !==null && typeof obj.getId === 'function')
      filter[idKey] = new ObjectID(obj.getId());
    else
      throw new ValmineError.getInstance("The current object passed for delete does'nt have an getId method");
    if(util.isCallbackMissed(callback))
      throw new ValmineError.getInstance(new TypeError(util.getParamErr('remove','callback')));
    db.collection(collection).removeOne(filter, {w:1}, function(err, res) {
      if(err) console.log(err);
      callback(err,res);
    });
  }

  /**
  * Returns the current database instance
  * @returns {DB}
  */
  this.getDb = function () {
    return db;
  }
}

module.exports = MainModel;
